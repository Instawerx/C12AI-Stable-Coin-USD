# C12USD Stablecoin - GCP Deployment Pipeline
# Production-ready CI/CD pipeline with security and quality checks

name: 'Deploy to Google Cloud Platform'

on:
  push:
    branches:
      - main      # Production deployment
      - staging   # Staging deployment
  pull_request:
    branches:
      - main
      - staging
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      force_deploy:
        description: 'Force deployment (skip tests)'
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: '20'
  REGISTRY_LOCATION: 'us-central1'
  TERRAFORM_VERSION: '1.10.0'

# Ensure only one deployment runs at a time per environment
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: false

jobs:
  # Determine deployment environment
  setup:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      project_id: ${{ steps.env.outputs.project_id }}
      should_deploy: ${{ steps.env.outputs.should_deploy }}
    steps:
      - name: Determine environment
        id: env
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
            echo "environment=production" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          elif [ "${{ github.ref }}" = "refs/heads/staging" ]; then
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=true" >> $GITHUB_OUTPUT
          else
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "should_deploy=false" >> $GITHUB_OUTPUT
          fi

          if [ "${{ steps.env.outputs.environment }}" = "production" ]; then
            echo "project_id=c12usd-production" >> $GITHUB_OUTPUT
          else
            echo "project_id=c12usd-staging" >> $GITHUB_OUTPUT
          fi

  # Security and quality checks
  security-checks:
    runs-on: ubuntu-latest
    needs: setup
    if: ${{ !github.event.inputs.force_deploy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Run type checking
        run: npm run typecheck

      - name: Run security audit
        run: npm audit --audit-level=moderate

      - name: Run SAST security scan
        uses: securecodewarrior/github-action-add-sarif@v1
        with:
          sarif-file: 'security-scan-results.sarif'
        continue-on-error: true

      - name: Scan for secrets
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: main
          head: HEAD

  # Run tests
  test:
    runs-on: ubuntu-latest
    needs: setup
    if: ${{ !github.event.inputs.force_deploy }}
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_PASSWORD: test_password
          POSTGRES_DB: c12usd_test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Setup test database
        run: |
          npm run db:migrate
        env:
          DATABASE_URL: postgresql://postgres:test_password@localhost:5432/c12usd_test

      - name: Run unit tests
        run: npm test
        env:
          NODE_ENV: test
          DATABASE_URL: postgresql://postgres:test_password@localhost:5432/c12usd_test

      - name: Run integration tests
        run: npm run test:db
        env:
          NODE_ENV: test
          DATABASE_URL: postgresql://postgres:test_password@localhost:5432/c12usd_test

      - name: Generate test coverage
        run: npm run coverage

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info

  # Build and push container image
  build:
    runs-on: ubuntu-latest
    needs: [setup, security-checks, test]
    if: ${{ needs.setup.outputs.should_deploy == 'true' && (success() || github.event.inputs.force_deploy) }}
    outputs:
      image_tag: ${{ steps.build.outputs.image_tag }}
      image_digest: ${{ steps.build.outputs.image_digest }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Configure Docker for Artifact Registry
        run: gcloud auth configure-docker ${{ env.REGISTRY_LOCATION }}-docker.pkg.dev

      - name: Generate image tag
        id: tag
        run: |
          SHORT_SHA=$(echo ${{ github.sha }} | cut -c1-7)
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          IMAGE_TAG="${TIMESTAMP}-${SHORT_SHA}"
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Build and push container image
        id: build
        run: |
          IMAGE_URI="${{ env.REGISTRY_LOCATION }}-docker.pkg.dev/${{ needs.setup.outputs.project_id }}/c12usd-repo/c12usd-backend:${{ steps.tag.outputs.image_tag }}"

          # Build image with security best practices
          docker build \
            --build-arg NODE_ENV=${{ needs.setup.outputs.environment }} \
            --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
            --build-arg VCS_REF=${{ github.sha }} \
            --tag ${IMAGE_URI} \
            --file Dockerfile .

          # Push image
          docker push ${IMAGE_URI}

          # Get image digest for security signing
          IMAGE_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${IMAGE_URI} | cut -d'@' -f2)

          echo "image_tag=${{ steps.tag.outputs.image_tag }}" >> $GITHUB_OUTPUT
          echo "image_digest=${IMAGE_DIGEST}" >> $GITHUB_OUTPUT

      - name: Sign container image (production only)
        if: ${{ needs.setup.outputs.environment == 'production' }}
        run: |
          # Install cosign for container signing
          curl -O -L "https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64"
          sudo mv cosign-linux-amd64 /usr/local/bin/cosign
          sudo chmod +x /usr/local/bin/cosign

          # Sign the container image
          IMAGE_URI="${{ env.REGISTRY_LOCATION }}-docker.pkg.dev/${{ needs.setup.outputs.project_id }}/c12usd-repo/c12usd-backend:${{ steps.tag.outputs.image_tag }}"
          cosign sign --key ${{ secrets.COSIGN_PRIVATE_KEY }} ${IMAGE_URI}

  # Terraform infrastructure deployment
  terraform:
    runs-on: ubuntu-latest
    needs: [setup, build]
    if: ${{ needs.setup.outputs.should_deploy == 'true' && (success() || github.event.inputs.force_deploy) }}
    environment: ${{ needs.setup.outputs.environment }}
    defaults:
      run:
        working-directory: ./deploy/gcp/terraform
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Terraform Init
        run: terraform init -backend-config="bucket=${{ needs.setup.outputs.project_id }}-terraform-state"

      - name: Terraform Format Check
        run: terraform fmt -check

      - name: Terraform Validate
        run: terraform validate

      - name: Terraform Plan
        run: |
          terraform plan \
            -var-file="../environments/${{ needs.setup.outputs.environment }}.tfvars" \
            -var="project_id=${{ needs.setup.outputs.project_id }}" \
            -out=tfplan
        env:
          TF_VAR_organization_id: ${{ secrets.GCP_ORGANIZATION_ID }}
          TF_VAR_notification_email: ${{ secrets.NOTIFICATION_EMAIL }}

      - name: Terraform Apply
        if: ${{ github.event_name != 'pull_request' }}
        run: terraform apply -auto-approve tfplan

      - name: Save Terraform outputs
        if: ${{ github.event_name != 'pull_request' }}
        run: |
          terraform output -json > terraform-outputs.json
          echo "CLOUD_RUN_URL=$(terraform output -raw cloud_run_service_url)" >> $GITHUB_ENV

      - name: Upload Terraform outputs
        if: ${{ github.event_name != 'pull_request' }}
        uses: actions/upload-artifact@v4
        with:
          name: terraform-outputs-${{ needs.setup.outputs.environment }}
          path: ./deploy/gcp/terraform/terraform-outputs.json

  # Deploy application to Cloud Run
  deploy:
    runs-on: ubuntu-latest
    needs: [setup, build, terraform]
    if: ${{ needs.setup.outputs.should_deploy == 'true' && (success() || github.event.inputs.force_deploy) }}
    environment: ${{ needs.setup.outputs.environment }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_SA_KEY }}

      - name: Setup Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Deploy to Cloud Run
        run: |
          SERVICE_NAME="c12usd-${{ needs.setup.outputs.environment }}-api"
          IMAGE_URI="${{ env.REGISTRY_LOCATION }}-docker.pkg.dev/${{ needs.setup.outputs.project_id }}/c12usd-repo/c12usd-backend:${{ needs.build.outputs.image_tag }}"

          gcloud run deploy ${SERVICE_NAME} \
            --image=${IMAGE_URI} \
            --platform=managed \
            --region=${{ env.REGISTRY_LOCATION }} \
            --project=${{ needs.setup.outputs.project_id }} \
            --allow-unauthenticated=${{ needs.setup.outputs.environment == 'staging' }} \
            --tag=v${{ needs.build.outputs.image_tag }}

      - name: Update traffic (production canary deployment)
        if: ${{ needs.setup.outputs.environment == 'production' }}
        run: |
          SERVICE_NAME="c12usd-production-api"

          # Deploy to canary with 5% traffic
          gcloud run services update-traffic ${SERVICE_NAME} \
            --to-tags=v${{ needs.build.outputs.image_tag }}=5 \
            --region=${{ env.REGISTRY_LOCATION }} \
            --project=${{ needs.setup.outputs.project_id }}

          echo "Canary deployment successful. Monitor metrics before promoting to 100%."

  # Post-deployment verification
  verify:
    runs-on: ubuntu-latest
    needs: [setup, deploy, terraform]
    if: ${{ needs.setup.outputs.should_deploy == 'true' && (success() || github.event.inputs.force_deploy) }}
    steps:
      - name: Download Terraform outputs
        uses: actions/download-artifact@v4
        with:
          name: terraform-outputs-${{ needs.setup.outputs.environment }}

      - name: Health check
        run: |
          CLOUD_RUN_URL=$(cat terraform-outputs.json | jq -r '.cloud_run_service_url.value')

          # Wait for service to be ready
          sleep 30

          # Perform health check
          curl -f "${CLOUD_RUN_URL}/health" || exit 1
          echo "Health check passed!"

      - name: Run smoke tests
        run: |
          CLOUD_RUN_URL=$(cat terraform-outputs.json | jq -r '.cloud_run_service_url.value')

          # Test basic API endpoints
          curl -f "${CLOUD_RUN_URL}/api/health" || exit 1
          curl -f "${CLOUD_RUN_URL}/api/status" || exit 1
          echo "Smoke tests passed!"

      - name: Performance test (production only)
        if: ${{ needs.setup.outputs.environment == 'production' }}
        run: |
          CLOUD_RUN_URL=$(cat terraform-outputs.json | jq -r '.cloud_run_service_url.value')

          # Simple load test
          npx Artillery quick --count 10 --num 100 "${CLOUD_RUN_URL}/health"

  # Notify deployment status
  notify:
    runs-on: ubuntu-latest
    needs: [setup, deploy, verify]
    if: always() && needs.setup.outputs.should_deploy == 'true'
    steps:
      - name: Notify Slack on success
        if: ${{ success() }}
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_MESSAGE: |
            🚀 C12USD successfully deployed to ${{ needs.setup.outputs.environment }}!

            • Environment: ${{ needs.setup.outputs.environment }}
            • Commit: ${{ github.sha }}
            • Author: ${{ github.actor }}
            • Image: c12usd-backend:${{ needs.build.outputs.image_tag }}

      - name: Notify Slack on failure
        if: ${{ failure() }}
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_COLOR: danger
          SLACK_MESSAGE: |
            ❌ C12USD deployment to ${{ needs.setup.outputs.environment }} failed!

            • Environment: ${{ needs.setup.outputs.environment }}
            • Commit: ${{ github.sha }}
            • Author: ${{ github.actor }}
            • Check the workflow for details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

      - name: Create GitHub deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const state = '${{ job.status }}' === 'success' ? 'success' : 'failure';
            const environment = '${{ needs.setup.outputs.environment }}';

            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: context.payload.deployment?.id || 0,
              state: state,
              environment_url: process.env.CLOUD_RUN_URL,
              description: `Deployment ${state} for ${environment} environment`
            });